#! /bin/bash
# vim: set ts=4 sw=4 et :

# Copyright 2018 Red Hat, Inc. and/or its affiliates.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Based on this spec:
# https://github.com/kubernetes/community/blob/master/contributors/devel/flexvolume.md

# if DEBUG, log everything to a file as we do it
if [ ! -n "${DEBUG}" ]; then
    DEBUG=1
elif [ "${DEBUG}" == 2 ]; then
    set -x
fi
DEBUGFILE='/tmp/glfs-block-subdir.out'
TIME=$(date +%s.%N)

RC_OK=0
RC_FAIL=1

cd "$(dirname "$0")" || exit 2
scriptdir="$PWD"
cd "$OLDPWD" || exit 2
MOUNTPATH=${scriptdir}/mnt/blockstore
LOCKPATH=/var/lock/glfs-block-subvol

#-- Make an entry in the log file (if enabled)
function log() {
    if [[ $DEBUG -gt 0 ]]; then
        echo "[$TIME] $*" >> $DEBUGFILE
    fi
}

#-- Log a command, then execute it
function execute() {
    log "! $*"
    "$@"
}

#-- Return the result of the operation
function retResult() {
    local rc=$1
    local result="$2"
    log "< $rc $result"
    echo "$result"
    exit "$rc"
}

function doInit() {
    local result
    local msg=""
    mkdir -p "$MOUNTPATH" >& /dev/null || \
        msg="${msg} Unable to create ${MOUNTPATH}"
    mkdir -p "$LOCKPATH" >& /dev/null || \
        msg="${msg} Unable to create ${LOCKPATH}"
    if [[ "x$msg" != "x" ]] ; then
        result="{\"status\": \"Failure\", \"message\": \"${msg}\"}"
    else
        result="{\"status\": \"Success\", \"capabilities\": {\"attach\": false, \"selinuxRelabel\": false}}"
    fi
    retResult $RC_OK "$result"
}

function mountName() {
    local vserver=$1
    local volume=$2
    local subdir=$3
    echo "$vserver-$volume" | sed 's_/_-_g'
}

function doMount() {
    # Example plugin call:
    # mount /var/lib/kubelet/pods/4a5ac08a-844b-11e7-9415-5254002b3544/volumes/rht~glfs-subvol/vol1
    # { "cluster":"glusterfs-cluster",
    #   "dir":"blockstore/00/00",
    #   "kubernetes.io/<fields>,
    #   ...,
    #   "volume":"vol1",
    #   "file":"0000"
    #   }
    # How we want to mount:
    # mount -t glusterfs -o backup-volfile-servers=192.168.121.201:192.168.121.233 192.168.121.172:/vol1 /tmp/t
    local mountdir="$1"
    local json="$2"

    local cluster
    cluster=$(echo "$2" | $JQ -r '.cluster')
    local volume
    volume=$(echo "$json" | $JQ -r '.volume')
    local subdir
    subdir=$(echo "$json" | $JQ -r '.dir')
    local blockfile
    blockfile=$(echo "$json" | $JQ -r '.file')
    if [ ! -n "${cluster}" ] || [ ! -n "${volume}" ] || [ ! -n "${subdir}" ] || [ ! -n "${blockfile}" ]; then
        local msg="cluster=$cluster volume=$volume subdir=$subdir blockfile=$blockfile"
        local result="{\"status\": \"Failure\", \"message\": \"$msg\"}"
        retResult $RC_FAIL "$result"
        return
    fi

    # cluster is "server1:server2:..."
    # Take the 1st as volserver and rest as backups
    local volserver
    volserver=$(echo "$cluster" | sed -r 's/^([^:]+):?(.*)/\1/')
    local backupservers
    backupservers=$(echo "$cluster" | sed -r 's/^([^:]+):?(.*)/\2/')

    local mntsuffix
    mntsuffix=$(mountName "$volserver" "$volume" "$subdir")
    local mountname
    mountname=${MOUNTPATH}/${mntsuffix}

    log volserver "$volserver"
    log backupservers "$backupservers"

    local msg="volserver=$volserver backup=$backupservers volume=$volume mountpoint=$mountname bindto=$mountdir"
    if [ ! -n "${volserver}" ] || [ ! -n "${backupservers}" ] || [ ! -n "${volume}" ] || [ ! -n "${mountname}" ]; then
        local result="{\"status\": \"Failure\", \"message\": \"$msg\"}"
        retResult $RC_FAIL "$result"
        return
    fi

    #-- This script can potentially be called multiple times in parallel by
    #-- different pods that are starting. We need to ensure that the big
    #-- volume is mounted atomically wrt other invocations.
    #-- See man 1 flock for this structure
    local lockfile="${LOCKPATH}/${mntsuffix}.lock"
    log "Using lockfile: $lockfile"
    ( flock 9 || exit 99
        # if main vol not mounted, we need to mount it
        if ! mountpoint -q "$mountname"; then
            mkdir -p "$mountname"
            execute mount -t glusterfs -o "backup-volfile-servers=${backupservers}" "${volserver}:/${volume}" "${mountname}"
        fi
        # bind must also be protected to ensure nobody unmounts before we
        # can bind
        if mountpoint -q "$mountname"; then
            execute mount "${mountname}/${subdir}/${blockfile}" "${mountdir}" -t xfs -o loop,discard
        fi
        # force unlock due to fork of mount process
        flock -u -n 9
    ) 9>> "${lockfile}"
    if [[ $? == 99 ]]; then
        log "flock of $lockfile failed."
    fi

    if mountpoint -q "${mountdir}"; then
        local result="{\"status\": \"Success\", \"message\": \"$msg\"}"
        retResult $RC_OK "$result"
    else
        local result="{\"status\": \"Failure\", \"message\": \"$msg\"}"
        retResult $RC_FAIL "$result"
    fi
}

function doUnmount() {
    # unmount /var/lib/kubelet/pods/79cd720f-868e-11e7-b571-5254002b3544/volumes/rht~glfs-subvol/vol1
    local mountdir=$1
    local msg="Unmounting from ${mountdir}"

    if ! mountpoint -q "${mountdir}"; then
        result="{\"status\": \"Success\", \"message\": \"Was not mounted.\"}"
        retResult $RC_OK "$result"
    fi

    # The actual gluster mount (device portion)
    local ldevice
    ldevice=$(grep "$mountdir" /proc/mounts | awk '{ print $1 }')
    local ldevicefile
    ldevicefile=$(losetup -n -O BACK-FILE "${ldevice}")
    local gdevicedir
    gdevicedir=$(echo "$ldevicefile" | grep -oE "${MOUNTPATH}/[^\/]*")
    local mntsuffix
    mntsuffix=$(echo "$gdevicedir" | sed -r "s#${MOUNTPATH}/##")
    log "ldevicefile=$ldevicefile"
    log "gdevicedir=$gdevicedir"
    log "mntsuffix=$mntsuffix"

    local result
    result=""
    local rc
    rc=""
    if execute umount "${mountdir}"; then
        result="{\"status\": \"Success\", \"message\": \"$msg\"}"
        rc=$RC_OK
    else
        result="{\"status\": \"Failure\", \"message\": \"$msg\"}"
        rc=$RC_FAIL
    fi

    # Try to be a good citizen and clean up after ourselves...
    # If we were the last user of the big volume, unmount it.
    # Note, we must use the same lock here as we do for mounting.
    local lockfile="${LOCKPATH}/${mntsuffix}.lock"
    log "Using lockfile: $lockfile"
    ( flock 9 || exit 99
        local mcount
        mcount=$(losetup --list -O BACK-FILE | grep -c "$gdevicedir")
        log "$gdevicedir has $mcount loop mounted files"
        if [[ "$mcount" -eq 0 ]]; then
            # We were the last
            log "We were last user of $gdevicedir; unmounting it."
            execute umount "$gdevicedir"
            execute rmdir "$gdevicedir"
            # Unfortunately, we need to leave the .lock file or we lose
            # protection
        fi
    ) 9>> "${lockfile}"
    if [[ $? == 99 ]]; then
        log "flock of $lockfile failed."
    fi

    retResult $rc "$result"
}


#-- make sure jq is installed
JQ=$(which jq 2> /dev/null || echo "$scriptdir/jq")
if [[ ! -x ${JQ} ]]; then
    rMessage="Unable to find 'jq' in PATH. Please install jq."
    retResult $RC_FAIL "$rMessage"
fi
if ! which flock >& /dev/null; then
    rMessage="Unable to find 'flock' in PATH. Please install flock."
    retResult $RC_FAIL "$rMessage"
fi

log "> $*"
cmd=$1
shift
case $cmd in
init)
    doInit "$@"
    ;;
mount)
    doMount "$@"
    ;;
unmount)
    doUnmount "$@"
    ;;
*)
    result="{\"status\": \"Not supported\", \"message\": \"$cmd is not supported\"}"
    retResult $RC_OK "$result"
    ;;
esac
